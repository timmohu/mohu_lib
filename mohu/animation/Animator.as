package mohu.animation {	import flash.display.DisplayObject;	import flash.display.Shape;	import flash.events.Event;	public class Animator {		public static const instance:Animator = new Animator();		public static function add(delay:Delay):Delay {			return Animator.instance.add(delay);		}		public static function remove(delay:Delay, addChildren:Boolean = true, fastForward:Boolean = false):Boolean {			return Animator.instance.remove(delay, addChildren, fastForward);		}		public static function wipe(addChildren:Boolean = false, fastForward:Boolean = false):void {			Animator.instance.wipe(addChildren, fastForward);		}		public static function destroy():void {			Animator.instance.destroy();		}		public static function get delays():Vector.<Delay> {			return Animator.instance.delays;		}		public static function get paused():Boolean {			return Animator.instance.paused;		}		public static function set paused(value:Boolean):void {			Animator.instance.paused = value;		}		private var _target:DisplayObject;		private var _delays:Vector.<Delay>;		private var _paused:Boolean;		public function Animator() {			_target = new Shape();			_delays = new Vector.<Delay>;			_paused = true;			this.paused = false;		}		public function add(delay:Delay):Delay {			for each (var otherDelay:Delay in _delays) if (otherDelay._overwrite(delay)) this.remove(otherDelay, false);			if (delay.duration == 0) {				delay.onStart.dispatch();				delay.onEnterFrame.dispatch();				for each (var childDelay:Delay in delay.children) this.add(childDelay);				delay.onComplete.dispatch();			} else {				_delays.push(delay);				delay.onStart.dispatch();			}			return delay;		}		public function remove(delay:Delay, addChildren:Boolean = true, fastForward:Boolean = false):Boolean {			if (fastForward) delay.currentFrame = delay.duration;			var index:int = _delays.indexOf(delay);			if (index == -1) return false;			_delays.splice(index, 1);			if (addChildren) for each (var childDelay:Delay in delay.children) this.add(childDelay);			delay.onComplete.dispatch();			return true;		}		public function wipe(addChildren:Boolean = false, fastForward:Boolean = false):void {			for each (var delay:Delay in _delays) this.remove(delay, addChildren, fastForward);		}		public function destroy():void {			wipe();			this.paused = true;			_delays = null;			_target = null;		}		public function get paused():Boolean {			return _paused;		}		public function get delays():Vector.<Delay> {			return _delays.slice();		}		public function set paused(value:Boolean):void {			if (_paused == value) return;			_paused = value;			if (value) _target.removeEventListener(Event.ENTER_FRAME, _handleEnterFrame); else _target.addEventListener(Event.ENTER_FRAME, _handleEnterFrame);		}		private function _handleEnterFrame(event:Event):void {			var delays:Vector.<Delay> = _delays;			for (var i:int = 0 ;i < delays.length ;i++) {				var delay:Delay = delays[i];				if (delay.paused) continue;				delay.currentFrame++;				delay.onEnterFrame.dispatch();				if (delay.currentFrame < delay.duration) continue; 				delays.splice(i--, 1);				for each (var childDelay:Delay in delay.children) this.add(childDelay);				delay.onComplete.dispatch();			}		}	}}
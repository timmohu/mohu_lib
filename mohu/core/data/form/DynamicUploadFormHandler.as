package mohu.core.data.form {	import flash.utils.ByteArray;	public class DynamicUploadFormHandler extends FormHandler {		private static const BOUNDARY:String = Math.round(Math.random() * uint.MAX_VALUE).toString(16);		public function DynamicUploadFormHandler( url:String = null, vars:Object = null, dataFormat:String = "text", requestHeaders:Array = null) {			super(url, vars, POST, dataFormat, "multipart/form-data; boundary=" + BOUNDARY, requestHeaders);		}						override protected function getRequestData():Object {			var bytes:ByteArray = new ByteArray();			for ( var key:String in vars ) bytes.writeBytes(getField(key, vars[key]));			writeBoundary(bytes);			writeDoubleDash(bytes);			return bytes;		}						private function getField( name:String, value:Object ):ByteArray {			var bytes:ByteArray = new ByteArray();			if ( value is Array ) {				for each ( var v : Object in value ) bytes.writeBytes(getFieldBytes(name + "[]", v));			} else {				bytes.writeBytes(getFieldBytes(name, value));			}			return bytes;		}						private function getFieldBytes( name:String, value:Object ):ByteArray {			var header:String = "Content-Disposition: form-data; name=\"" + name + "\"";			var bytes:ByteArray;			if ( value is DynamicFileUpload ) {				var file:DynamicFileUpload = value as DynamicFileUpload;				header += "; filename=\"" + file.filename + "\"\r\nContent-Type: application/octet-stream";				bytes = file.data;			} else {				bytes = makeByteArray(value !== null ? value.toString() : null);			}			return makeField(header, bytes);		}						private function makeField( header:String, bytes:ByteArray):ByteArray {			var ba:ByteArray = new ByteArray();			writeBoundary(ba);			writeLineBreak(ba);			ba.writeUTFBytes(header);			writeLineBreak(ba);			writeLineBreak(ba);			if (bytes != null) ba.writeBytes(bytes);			writeLineBreak(ba);			return ba;					}						private function makeByteArray( data:String, utf:Boolean = true ):ByteArray {			var bytes:ByteArray = new ByteArray();			if ( !data ) return bytes;			if ( utf ) {				bytes.writeUTFBytes(data);			} else {				for ( var i:int = 0;i < data.length;i++ ) bytes.writeByte(data.charCodeAt(i));			}			return bytes;		}						private function writeBoundary( bytes:ByteArray ):void {			writeDoubleDash(bytes);			bytes.writeBytes(makeByteArray(BOUNDARY, false));		}						private function writeLineBreak( bytes:ByteArray ):void {			bytes.writeShort(0x0d0a);		}						private function writeDoubleDash( bytes:ByteArray ):void {			bytes.writeShort(0x2d2d);		}	}}